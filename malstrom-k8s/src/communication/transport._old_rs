//! A transport for Malstrom communication which uses Kameo Actors
use jetstream::runtime::communication::{Transport, TransportError};
use kameo::{
    actor::RemoteActorRef, error::RegistrationError, Actor, RemoteActor,
};
use log::{debug, error};
use std::{sync::Mutex, time::Duration};
use tokio::runtime::Handle;
use tokio::{sync::Notify, task::JoinHandle};

use backon::ConstantBuilder;
use backon::Retryable;
use kameo::request::MessageSend;
use thiserror::Error;

pub(super) struct ActorTransportHandle {
    // send into this sender to put a msg into the outgoing buffer
    outgoing: kanal::Sender<Vec<u8>>,
    // last received message
    incoming: kanal::Receiver<Vec<u8>>,
}

#[derive(Actor, RemoteActor)]
#[actor(name = "ActorTransport", mailbox = bounded(512))]
pub(super) struct ActorTransport {
    // last received message
    incoming: kanal::Sender<Vec<u8>>,
    // thread which sends outgoing messages
    outgoing_thread: JoinHandle<()>,
}

#[derive(Debug, Error)]
enum LookupError {
    #[error("Actor with the given name was not found")]
    NotFound,
    #[error(transparent)]
    RegistrationError(#[from] RegistrationError),
}

impl ActorTransport {
    pub(super) fn new(runtime: &Handle, to_worker: usize, to_operator: usize) -> (Self, ActorTransportHandle) {
        let (outgoing_tx, outgoing_rx) = kanal::bounded(512);
        let (incoming_tx, incoming_rx) = kanal::bounded(512);

        let remote_name = format!("{}{}", to_worker, to_operator);

        let outgoing_thread = runtime.spawn(async move {
            let remote_lookup = || async {
                debug!("Looking up actor {remote_name}");
                match RemoteActorRef::<ActorTransport>::lookup(&remote_name).await {
                    Ok(Some(x)) => Ok(x),
                    Ok(None) => Err(LookupError::NotFound),
                    Err(e) => Err(LookupError::from(e)),
                }
            };

            let remote_actor = remote_lookup
                .retry(ConstantBuilder::default().with_max_times(180))
                .sleep(tokio::time::sleep)
                .when(|err| match err {
                    LookupError::NotFound => {error!("{} not found, retrying...", remote_name); true},
                    LookupError::RegistrationError(RegistrationError::Timeout) => {error!("{}, retrying...", remote_name); true},
                    _ => false,
                })
                .await
                .unwrap();

            loop {
                let msg = outgoing_rx.recv().unwrap();
                remote_actor
                    .tell(&msg)
                    .mailbox_timeout(Duration::from_secs(10))
                    .send()
                    .await
                    .unwrap();
            }
        });

        let handle = ActorTransportHandle{
            outgoing: outgoing_tx,
            incoming: incoming_rx
        };

       ( Self {
            incoming: incoming_tx,
            outgoing_thread,
        }, handle)
    }
}

#[kameo::remote_message("ActorTransport_Binary")]
impl kameo::message::Message<Vec<u8>> for ActorTransport {
    type Reply = (); // no-reply

    async fn handle(
        &mut self,
        msg: Vec<u8>,
        _ctx: kameo::message::Context<'_, Self, Self::Reply>,
    ) -> Self::Reply {
        self.incoming.send(msg).unwrap()
    }
}

impl Transport for ActorTransportHandle {
    fn send(&self, msg: Vec<u8>) -> Result<(), TransportError> {
        self.outgoing.send(msg).map_err(TransportError::send_error)
    }

    fn recv(&self) -> Result<Option<Vec<u8>>, TransportError> {
        Ok(self.incoming.recv().ok())
    }
}

/// Store a single T, write it from the async side an retreive it
/// from the sync side. If the location for T is still occupied, the async side
/// will wait
/// Inspired by https://dtantsur.github.io/rust-openstack/tokio/sync/struct.Notify.html
#[derive(Default, Clone)]
struct Wait<T> {
    value: Mutex<Option<T>>,
    notify: Notify,
}

impl<T> Wait<T> {
    /// Put something in the Wait, waiting until there is
    /// space if necessary
    async fn put(&self, value: T) -> () {
        // wait for free slot
        self.notify.notified().await;
        *self.value.lock().unwrap() = Some(value);
    }

    fn take(&self) -> Option<T> {
        let val = self.value.lock().unwrap().take();
        // notify waiting task there is space again
        if val.is_some() {
            self.notify.notify_one();
        }
        val
    }
}
